(printLn "")
(printLn "ЗАДАЧА - функция, вычисляющая число Фибоначчи экспоненциальным алгоритмом:")
(defn fib (n)
    (defn fib-iter (a b p q count)
      (cond (= count 0) b
        (= count (* 2 (/ count 2))) (fib-iter a b (+ (* p p) (* q q)) (+ (* q q) (* 2 p q)) (/ count 2) )
        True          (fib-iter (+ (* b q) (* a q) (* a p)) (+ (* b p) (* a q)) p q (- count 1)) ))
    (fib-iter 1 0 0 1 n))
(def n 1000)
(printLn (str "fib[" n "]=" (fib n)))

(printLn "")
(printLn "ЗАДАЧА - функция, вычисляющая квадратный корень:")
(defn sqrt (x) (
    (defn sqrt-iter (guess) (cond (good-enough? guess) guess (sqrt-iter (improve guess))))
    (defn good-enough? (guess) (<' (abs (-' ((lambda (x) (*' x x)) guess) x)) 0.000001))
    (defn improve (guess) (average guess (/' x guess)))
    (defn average (x y) (/' (+' x y) 2))
    (defn abs (x) (cond (<' x 0) (-' 0 x) x))
    (sqrt-iter 1)))
(def a 4)
(printLn (str "квадратный корень из" a "равен" (sqrt a)))

(printLn "")
(printLn "ЗАДАЧА - сформировать список частичных сумм заданного списка:")
(defn foo1 (l)
    (defn go (l s) (cond (null? l) nil (cons (+ s (car l)) (go (cdr l) (+ s (car l))))))
    (go l 0))
(defn foo2 (l)
    (defn go (l s r) (cond (null? l) r (go (cdr l) (+ s (car l)) (cons (+ s (car l)) r))))
    (reverse (go l 0 nil)))
(defn foo3 (l)
    (def s 0)
    (defn f (x a) (begun (set! s (+ s x)) (cons s a)))
    (reverse (foldl f nil l)))
(def l '(3 2 6 5 1))
(printLn (str "исходный список" l))
(printLn (str "результаты : 1:" (foo1 l) "2:" (foo2 l) "3:" (foo3 l)))

(printLn "")
(printLn "ЗАДАЧА - умножение многочленов:")
(defn poly-mul (a b) (
    (defn winfold (l1 l2 acc)
        (cond (null? l1) acc
              (null? l2) acc
              (winfold (cdr l1) (cdr l2) (+ (* (car l1) (car l2)) acc))))
    (defn addzeros (n l) (cond (= 0 n) l (addzeros (- n 1) (cons 0 l))))
    (def la (length a))
    (def lb (length b))
    (def a0 (addzeros (- lb 1) a))
    (def b0 (addzeros (+ la lb -2) (reverse b)))
    (defn go (n a b r) (cond (= 0 n) r (go (- n 1) a (cdr b) (cons (winfold a b 0) r))))
    (go (+ la lb -1) a0 b0 nil)))
(defn print-poly (l)
    (print "(")
    (defn go (l i)
        (cond (null? l) (print ")") (
          (print (cond (> (car l) 0) "+" ""))
          (print (car l))
          (cond (= i 0) ""
                (= i 1) (print "x")
                ((print "x^") (print i)))
          (go (cdr l) (+ i 1)))))
    (go l 0))
(def a '(0 1 2 3)) (def b '(5 1 2 3))
(print-poly a) (print " * ") (print-poly b) (print " = ") (print-poly (poly-mul a b))
(printLn "")

(printLn "")
(printLn "ЗАДАЧА - посчитать количество вхождения элементов в список:")
(defn foo (l)
    (defn collect (x l)
        (cond (null? l) (cons (cons x 1) nil)
              (eq? x (car (car l))) (cons (cons x (+ 1 (car (cdr (car l))))) (cdr l))
              (cons (car l) (collect x (cdr l)))))
    (foldl collect nil l))
(defn show-pair (l) (str (car l) : (car (cdr l))))
(defn print-pair (l) (begin (print (car l)) (print :) (print (car (cdr l))) (print " ")))
(def l '(h e l l o w o r l d))
(printLn (str "входящий список:" l))
(def r (foo l))
(printLn (str "результат:" r))
(printLn (str "или так:" (map show-pair r)))
(printLn "форматированный результат:") (map print-pair r) (printLn "")

(printLn "")
(printLn "ЗАДАЧА - исключить из первого множества элементы второго:")
(defn foo (l1 l2)
    (def l1' (flatten l1))
    (printLn (str "сглаженный список исходных элементов:" l1'))
    (def l2' (flatten l2))
    (printLn (str "сглаженный список исключаемых элементов:" l2'))
    (filter (lambda (x) (noelem x l2')) l1'))
(printLn "входящие аргументы функции - списки сложной структуры:")
(def l1 '(-10 (-9 ((-8 -7 -6)) -5 (((-4 -3))) -2 -1) 0 1 2 3 4))
(def l2 '(5 ((((((-6 -5 -4 -3)))))) ((-8 -7 -6 -5) (((3 4 5 6 7))))))
(printLn l1) (printLn l2) (printLn (str "результат:" (foo l1 l2)))

(printLn "")
(printLn "ЗАДАЧА - сформировать функции - производные n-го порядка исходной функции:")
(defn derivative (f) (lambda (x) (/' (-' (f (+' x 0.001)) (f x) ) 0.001)))
(defn n-der-1 (g n) (cond (> n 0) (derivative (n-der-1 g (- n 1))) g) )
(defn n-der-2 (g n) (cond (> n 0) (n-der-2 (derivative g) (- n 1)) g) )
(defn n-der-3 (f n)
    (defn iter (i g) (cond (> i 0) (iter (- i 1) (derivative g)) g) )
    (iter n f))
(defn f (x) (*' x x x x x)) (def n 3) (def x 1)
(printLn (str "функция:" f))
(printLn (str n "-я производная в точке" x "(вариант 1) =" ((n-der-1 f n) x)))
(printLn (str n "-я производная в точке" x "(вариант 2) =" ((n-der-2 f n) x)))
(printLn (str n "-я производная в точке" x "(вариант 3) =" ((n-der-3 f n) x)))

(printLn "")
(printLn "ЗАДАЧА - создать класс 'табуретка' и дочерний класс 'стул', переопределить поле:")
(defn make-tab (h qual)
    (def amount (cond (eq? qual low) (+ 12 (* 4 h)) (+ 14 (* 5 h)))) -- переопределяемое поле
    (defn dispatch (p)
        (cond (eq? getamount p) amount
              (eq? getprice  p) (* (cond (eq? qual low) 2 (eq? qual mid) 3 4) (dispatch getamount))
              (eq? getinfo   p) (str height: h , quality: qual
                                 , amount: (dispatch getamount) , price: (dispatch getprice))
              (eq? setamount (car p)) (set! amount (car (cdr p)))
              (print (str "Неизвестное имя метода:" p))))
    dispatch)
(defn make-chear (h hb qual)
    (def tab (make-tab h qual)) -- родительский объект (с неопределенной высотой)
    (tab (cons setamount (+ (tab getamount) (* 2 hb) 5))) -- переопределение значения внутреннего поля
    tab)
(printLn (str "табуретка (20, mid):" ((make-tab 20 mid) getinfo)))
(printLn (str "стул (10, 2, low):" ((make-chear 10 2 low) getinfo)))
